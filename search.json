[{"title":"Canal部署","url":"/2024/03/26/Canal%E9%83%A8%E7%BD%B2/","content":"拉取镜像docker pull canal/canal-server:v1.1.7\n\n启动容器并复制配置文件，然后删除容器docker run --name canal-server canal/canal-server:v1.1.7\ndocker cp canal-server:/home/admin/canal-server/conf /opt/canal\ndocker cp canal-server:/home/admin/canal-server/logs /opt/canal\ndocker stop canal-server &amp; docker rm canal-server\n\ndocker-compose.ymlversion: &#x27;3.5&#x27;services:  canal-server:    image: canal/canal-server:v1.1.7    container_name: canal-server    restart: always    ports:      - 11111:11111    privileged: true    environment:      - canal.auto.scan=true      - canal.destinations=xc-canal # canal实例名称，根据自己喜好命名      - canal.instance.mysql.slaveId=9527 # canal作为模仿从站的ID，不可与主站重复      - canal.instance.master.address=117.50.76.162:3306 #mysql的连接地址      - canal.instance.dbUsername=tlread # mysql的用户      - canal.instance.dbPassword=cdxc_read_2024 # mysql的密码      - canal.instance.connectionCharset=UTF-8      - canal.instance.tsdb.enable=true      - canal.instance.gtidon=false      - canal.instance.parser.parallelThreadSize=16      - canal.instance.filter.regex=api.news_a_share_rel # 此处为监听的正则表达式过滤，具体参考官网配置，多个用英文逗号隔开&quot;,&quot;,例如：dbname.tablename1,dbname.tablename2\n\n","categories":["docker"],"tags":["Canal"]},{"title":"Github资源","url":"/2021/12/06/Github%E8%B5%84%E6%BA%90/","content":"Free Programming Books\n在我看来，这是一个几乎汇集了所有免费的编程课程和书籍的网站。我最喜欢这里的一点是它区分了许多不同的语言，这可以帮助我们轻松选择适合自己的书。除了阅读文档之外，它还为，例如popcast、视频、代码演练……\n\nFree Programming Books\nWeb Developer Road Map\n2021 年成为 Web 开发人员的路线图，包括前端、后端和DevOps。\n\nWeb Developer Road Map\nCoding Interview University\n该仓库为开发人员提供了通往美国大型互联网公司的完整面试、学习指南，其中列出的题目和项目将为你在任何软件公司的技术面试前做好准备。\n\nCoding Interview University\nJavaScript Questions\n该网站汇总了 Javascript 编程语言从基础到高级的问题。我最喜欢它的一点是它对每个问题都有非常详细的答案和说明。它也被翻译成了许多不同的语言。\n\nJavaScript Questions\nClean Code Javascript\n它综合了作者在使用 Javascript编程语言工作期间的编码经验。它帮助我们学习如何编写易于理解、易于重用的代码，并提高代码的效率\n\nClean Code Javascript\nTech Interview Handbook\nThe Tech Interview Handbook是一个网站，它汇总了开发人员的面试经验，例如编写简历、介绍、面试常见问题、算法和编程中的常用技术\n\nTech Interview Handbook\nFree For Dev\nFree For Dev 是一个整合编程项目链接和免费网络服务的地方，例如网络托管、存储媒体处理、云提供商、API、CDN、DNS、CMS……\n\nFree For Dev\nPublic APIs\n公共 API 是用于网站开发的免费 API 服务的集合，例如用于体育、社会、天气、金融……的 API\n\nPublic APIs\nYou Don’t Know JS\n你不知道的JS是一本充满了在使用Javascript开发网站的过程中处理问题的方法的书。\n\nYou Don’t Know JS\nThe Front-End Checklist\n前端清单是您在网站投入生产之前所需的所有元素的列表\n\nThe Front-End Checklist\nNodejs Best Practices\nNodejs Best Practices 是一个存储从 Internet 上的项目链接收集的数百篇 Nodejs文章的地方。此外，还分了一些具体的话题，比如如何清理nodejs代码、如何处理错误、如何保护网站、如何测试、如何提高网站速度……使用Nodejs\n\nNodejs Best Practices\nAwesome\nAwesome是一个为开发人员合成几乎完整的链接项目的地方，例如编程语言、前端开发、后端、计算机科学文档、大数据、网络、内容管理系统……\n\nAwesome\nJavaScript Algorithms Và Data Structures\nJavaScript 算法和数据结构是常见数据结构和算法的真实世界示例的完整集合。\n\nJavaScript Algorithms Và Data Structures\nAwesome Python\nAwesome Python 是 Python 程序员的工具和文档集合，例如框架、库、软件……\n\nAwesome Python\nFull Stack Web Development\nFull Stack Web Development 是 100 多个免费项目链接的聚集地，可以学习 HTML、CSS、Nodejs、数据库、API 等网站开发……\n\nFull Stack Web Development\n","categories":["开发工具"],"tags":["Github资源"]},{"title":"IDEA优化","url":"/2020/10/06/IDEA%E4%BC%98%E5%8C%96/","content":"插件\nIDEA中的java开发辅助插件 \n\n快捷键提示: Key promoter X\n阿里巴巴编码规约: Alibaba Java Coding Guidelines\n代码侧边预览: CodeGlance \n代码提示工具: Codota AI Autocomplete for Java and JavaScript ,Alibaba Cloud AI Coding Assistant\nEclipse代码格式化: Eclipse Code Formatteer\n一键生成实体set方法: GenerateAllSetter\nJson-&gt;实体转换: GsonFormatPlus\n热部署: JRebel and XRebel for IntelliJ\nUI美化: Material Theme UI\nMaven辅助工具: Maven Helper\n代码生成: MyBatisCodeHelperPro\n对象转json: POJO to Json\n翻译: Translation\n汉化插件: Chinese\n括号美化: Rainbow Brackets\n接口查询以及模拟: RestfulTool\n序列化UUID生成: GenerateSerialVersionUID\n彩色日志: grep console\n快捷下划线转驼峰: CamelCase\n\n优化\n优化地址\n\n","categories":["开发工具"],"tags":["IDEA"]},{"title":"Nacos环境搭建(docker)","url":"/2020/10/06/Nacos%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(docker)/","content":"创建数据挂载目录mkdir -p /home/nacos/&#123;conf,nacos-1/&#123;logs&#125;,nacos-2/&#123;logs,nginx&#125;&#125;\n\n增加公共配置custom.propertiescd /home/nacos/conf\nvim custom.properties\n\nnacos.naming.empty-service.auto-clean=truenacos.naming.empty-service.clean.initial-delay-ms=50000nacos.naming.empty-service.clean.period-time-ms=30000management.metrics.export.elastic.enabled=falsemanagement.metrics.export.influx.enabled=falseserver.tomcat.accesslog.enabled=trueserver.tomcat.accesslog.pattern=%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;iserver.tomcat.basedir=nacos.security.ignore.urls=/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**nacos.core.auth.system.type=nacosnacos.core.auth.enabled=falsenacos.core.auth.default.token.expire.seconds=18000nacos.core.auth.default.token.secret.key=SecretKey012345678901234567890123456789012345678901234567890123456789nacos.core.auth.caching.enabled=truenacos.istio.mcp.server.enabled=false\n\n编写dockerc-compose.ymlcd /home/nacos\nvim docker-compose.yml\n\n单机环境version: &#x27;3&#x27;services:  nacos-server:    image: nacos/nacos-server:1.4.2    container_name: nacos-standalone    ports:      - 8848:8848    restart: always    networks:      - nacos_net    privileged: true    environment:      MODE: standalone      PREFER_HOST_MODE: 172.16.10.233  #如果支持主机名可以使用hostname,否则使用ip，默认也是ip      SPRING_DATASOURCE_PLATFORM: mysql #数据源平台 仅支持mysql或不保存empty      MYSQL_SERVICE_HOST: 172.16.10.233      MYSQL_SERVICE_PORT: 3306      MYSQL_SERVICE_DB_NAME: nacos      MYSQL_SERVICE_USER: root      MYSQL_SERVICE_PASSWORD: root      #JVM调优参数      JVM_XMS: 512m  #-Xms default :2g      JVM_MMS: 320m      JVM_XMX: 512m #-Xmx default :2g      JVM_XMN: 320m #-Xmn default :1g    #挂载目录    volumes:      - /home/unit/nacos/nacos-standalone/logs:/home/nacos/logs       - /home/unit/nacos/conf/custom.properties:/home/nacos/init.d/custom.properties networks:  nacos_net:    driver: bridge\n\n集群环境\n这里指定了docker内网的号段，需要提前创建好network，docker network create –driver=bridge –subnet=10.1.1.0/24 test-network\n\nversion: &#x27;3&#x27;networks:  my_network:    external: true    name: test-networkservices:   nacos1:    image: nacos/nacos-server:v2.3.1    container_name: nacos1    restart: always    privileged: true    environment:      MODE: cluster      NACOS_SERVERS: 10.1.1.40:8848,10.1.1.41:8848,10.1.1.42:8848      PREFER_HOST_MODE: hostname      SPRING_DATASOURCE_PLATFORM: mysql      MYSQL_SERVICE_HOST: 10.1.1.2      MYSQL_SERVICE_PORT: 3306      MYSQL_SERVICE_DB_NAME: nacos      MYSQL_SERVICE_USER: xc_ai      MYSQL_SERVICE_PASSWORD: fp!aRX33!zXS5tW      NACOS_AUTH_ENABLE: true # 开启鉴权      NACOS_AUTH_TOKEN: jqn3m9i51vr4tu5ip57zwcb3axbz1r6y6vssh7i5027xq7z5odzfaqvmjnrxenvn       NACOS_AUTH_IDENTITY_KEY: nacos       NACOS_AUTH_IDENTITY_VALUE: zwcb3axb #JVM调优参数      JVM_XMS: 320m  #-Xms default :2g      JVM_MMS: 125m      JVM_XMX: 320m #-Xmx default :2g      JVM_XMN: 125m #-Xmn default :1g    volumes:      - /home/nacos/cluster1/logs:/home/nacos/logs       - /home/nacos/cluster1/conf/custom.properties:/home/nacos/init.d/custom.properties       - /home/nacos/cluster1/data:/home/nacos/data    networks:      my_network:        ipv4_address: 10.1.1.40   nacos2:    image: nacos/nacos-server:v2.3.1    container_name: nacos2    restart: always    privileged: true    environment:      MODE: cluster      NACOS_SERVERS: 10.1.1.40:8848,10.1.1.41:8848,10.1.1.42:8848      PREFER_HOST_MODE: hostname      SPRING_DATASOURCE_PLATFORM: mysql      MYSQL_SERVICE_HOST: 10.1.1.2      MYSQL_SERVICE_PORT: 3306      MYSQL_SERVICE_DB_NAME: nacos      MYSQL_SERVICE_USER: xc_ai      MYSQL_SERVICE_PASSWORD: fp!aRX33!zXS5tW      NACOS_AUTH_ENABLE: true # 开启鉴权      NACOS_AUTH_TOKEN: jqn3m9i51vr4tu5ip57zwcb3axbz1r6y6vssh7i5027xq7z5odzfaqvmjnrxenvn       NACOS_AUTH_IDENTITY_KEY: nacos       NACOS_AUTH_IDENTITY_VALUE: zwcb3axb #JVM调优参数      JVM_XMS: 320m  #-Xms default :2g      JVM_MMS: 125m      JVM_XMX: 320m #-Xmx default :2g      JVM_XMN: 125m #-Xmn default :1g    volumes:      - /home/nacos/cluster2/logs:/home/nacos/logs       - /home/nacos/cluster2/conf/custom.properties:/home/nacos/init.d/custom.properties       - /home/nacos/cluster2/data:/home/nacos/data    networks:      my_network:        ipv4_address: 10.1.1.41           nacos3:    image: nacos/nacos-server:v2.3.1    container_name: nacos3    restart: always    privileged: true    environment:      MODE: cluster      NACOS_SERVERS: 10.1.1.40:8848,10.1.1.41:8848,10.1.1.42:8848      PREFER_HOST_MODE: hostname      SPRING_DATASOURCE_PLATFORM: mysql      MYSQL_SERVICE_HOST: 10.1.1.2      MYSQL_SERVICE_PORT: 3306      MYSQL_SERVICE_DB_NAME: nacos      MYSQL_SERVICE_USER: xc_ai      MYSQL_SERVICE_PASSWORD: fp!aRX33!zXS5tW      NACOS_AUTH_ENABLE: true # 开启鉴权      NACOS_AUTH_TOKEN: jqn3m9i51vr4tu5ip57zwcb3axbz1r6y6vssh7i5027xq7z5odzfaqvmjnrxenvn       NACOS_AUTH_IDENTITY_KEY: nacos       NACOS_AUTH_IDENTITY_VALUE: zwcb3axb #JVM调优参数      JVM_XMS: 320m  #-Xms default :2g      JVM_MMS: 125m      JVM_XMX: 320m #-Xmx default :2g      JVM_XMN: 125m #-Xmn default :1g    volumes:      - /home/nacos/cluster3/logs:/home/nacos/logs       - /home/nacos/cluster3/conf/custom.properties:/home/nacos/init.d/custom.properties       - /home/nacos/cluster3/data:/home/nacos/data    networks:      my_network:        ipv4_address: 10.1.1.42    \n\n编写nginx代理\n2.0之后使用rpc访问有一个端口偏移，需要在nginx配置中指定\n\nnginx.confcd /home/nginx/conf\nvim nginx.conf\n\nuser  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    keepalive_timeout  65;    include /etc/nginx/conf.d/*.conf;&#125; # tpc服务stream &#123;    # tcp负载均衡    upstream nacos-grpc &#123;        server 10.1.1.40:9848 weight=1;        server 10.1.1.41:9848 weight=1;        server 10.1.1.42:9848 weight=1;    &#125;                                                        # Nacos服务端gRPC请求服务端端口    server &#123;        listen 10999;        proxy_pass nacos-grpc;    &#125;  &#125;\nnacos.confcd /home/nginx/conf.d\nvim nacos.conf\n\nupstream nacosserver &#123;            server 10.1.1.40:8848 weight=1;            server 10.1.1.41:8848 weight=1;            server 10.1.1.42:8848 weight=1;    &#125;server &#123;        listen       9999;      server_name localhost;        location / &#123;            proxy_pass http://nacosserver;    &#125;&#125;\n执行启动命令docker-compose up -d \n\n\n最后只需要用nginx进行代理转发就好了\n\n","categories":["docker"],"tags":["nacos"]},{"title":"PowerDesigner脚本","url":"/2020/10/06/PowerDesigner%E8%84%9A%E6%9C%AC/","content":"Name转CommentOption   Explicit ValidationMode   =   True InteractiveMode   =   im_BatchDim   mdl   &#x27;   the   current   model&#x27;   get   the   current   active   model Set   mdl   =   ActiveModel If   (mdl   Is   Nothing)   Then       MsgBox   &quot;There   is   no   current   Model &quot; ElseIf   Not   mdl.IsKindOf(PdPDM.cls_Model)   Then       MsgBox   &quot;The   current   model   is   not   an   Physical   Data   model. &quot; Else       ProcessFolder   mdl End   If&#x27;   This   routine   copy   name   into   comment   for   each   table,   each   column   and   each   view &#x27;   of   the   current   folder Private   sub   ProcessFolder(folder)       Dim   Tab   &#x27;running     table       for   each   Tab   in   folder.tables             if   not   tab.isShortcut   then                   tab.comment   =   tab.name                   Dim   col   &#x27;   running   column                   for   each   col   in   tab.columns                         col.comment=   col.name                   next             end   if       next      Dim   view   &#x27;running   view       for   each   view   in   folder.Views             if   not   view.isShortcut   then                   view.comment   =   view.name             end   if       next      &#x27;   go   into   the   sub-packages       Dim   f   &#x27;   running   folder       For   Each   f   In   folder.Packages             if   not   f.IsShortcut   then                   ProcessFolder   f             end   if       Next end   sub\n\nComment转NameOption   Explicit ValidationMode   =   True InteractiveMode   =   im_BatchDim   mdl   &#x27;   the   current   model&#x27;   get   the   current   active   model Set   mdl   =   ActiveModel If   (mdl   Is   Nothing)   Then       MsgBox   &quot;There   is   no   current   Model &quot; ElseIf   Not   mdl.IsKindOf(PdPDM.cls_Model)   Then       MsgBox   &quot;The   current   model   is   not   an   Physical   Data   model. &quot; Else       ProcessFolder   mdl End   IfPrivate   sub   ProcessFolder(folder) On Error Resume Next      Dim   Tab   &#x27;running     table       for   each   Tab   in   folder.tables             if   not   tab.isShortcut   then                   tab.name   =   tab.comment                  Dim   col   &#x27;   running   column                   for   each   col   in   tab.columns                   if col.comment=&quot;&quot; then                  else                        col.name=   col.comment                   end if                  next             end   if       next      Dim   view   &#x27;running   view       for   each   view   in   folder.Views             if   not   view.isShortcut   then                   view.name   =   view.comment             end   if       next      &#x27;   go   into   the   sub-packages       Dim   f   &#x27;   running   folder       For   Each   f   In   folder.Packages             if   not   f.IsShortcut   then                   ProcessFolder   f             end   if       Next end   sub","categories":["开发工具"],"tags":["powerDesigner"]},{"title":"RocketMQ环境搭建 ( docker )","url":"/2023/06/27/RocketMQ%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%20(%20docker%20)/","content":"\n\n安装前先要安装好docker以及docker-compose\n\n\n常用资料地址\n官方文档地址：快速开始 | RocketMQ\n整合版单机镜像：xuchengen/rocketmq - Docker Image | Docker Hub\n此镜像 5.1.2 版本存在不能自定义配置文件的问题，几乎无法使用\n\n\nGitHub地址：apache/rocketmq: Apache RocketMQ is a cloud native messaging and streaming platform, making it simple to build event-driven applications.\n\n配置解析创建数据挂载目录mkdir -p /home/rocketmq/&#123;broker/conf,broker/logs,broker/store,console/logs,namesrv/logs&#125;\n\nbroker.conf目录：/home/rocketmq/broker/conf\n# 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭autoCreateTopicEnable=true# 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true# Broker角色# - ASYNC_MASTER 异步复制Master# - SYNC_MASTER 同步双写Master# - SLAVEbrokerRole=ASYNC_MASTER# 所属集群名字brokerClusterName = DefaultCluster# broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,# 在 broker-b.properties 使用: broker-bbrokerName = broker-a# 0 表示 Master，&gt; 0 表示 SlavebrokerId = 0# 启动 IP，修改为你宿主机的 IP# 如果是正式环境，这里一定要填写内网地址（安全）# 如果是用于测试或者本地这里建议要填外网地址，因为你的本地代码是无法连接到阿里云内网,只能连接外网#brokerIP1 = 192.168.199.10# 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4# 删除文件时间点，默认凌晨4点deleteWhen=04# 文件保留时间，默认48小时fileReservedTime = 120# 刷盘方式# - ASYNC_FLUSH 异步刷盘# - SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH# Broker 对外服务的监听端口listenPort=10911# 检测物理文件磁盘空间diskMaxUsedSpaceRatio=88# commitLog 每个文件的大小默认 1G，单位 bmapedFileSizeCommitLog=1073741824# ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整mapedFileSizeConsumeQueue=300000# 限制的消息大小，单位 bmaxMessageSize=524288# nameServer地址，分号分割# namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876# 存储路径# storePathRootDir=/home/ztztdata/rocketmq-all-4.1.0-incubating/store# commitLog 存储路径# storePathCommitLog=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/commitlog# 消费队列存储# storePathConsumeQueue=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/consumequeue# 消息索引存储路径# storePathIndex=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/index# checkpoint 文件存储路径# storeCheckpoint=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/checkpoint# abort 文件存储路径# abortFile=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/abort# 发消息线程池数量# sendMessageThreadPoolNums=128# 拉消息线程池数量# pullMessageThreadPoolNums=128# 未标注# destroyMapedFileIntervalForcibly=120000# redeleteHangedFileInterval=120000\n\n设置管理界面账号密码 /home/rocketmq/console/data/users.properties# This file supports hot change, any change will be auto-reloaded without Console restarting.# Format: a user per line, username=password[,N] #N is optional, 0 (Normal User); 1 (Admin) # Define Admin# =============用户名和密码规则「用户名=密码,权限」，这里的权限为1表示管理员，为0表示普通用户=============# 例如：admin=admin123,1admin=123456,1  # Define Users# =============屏蔽下边两个账户=============#user1=user1#user2=user2\n\ndocker-compose\nrocketmq.config.loginRequired:开启控制台访问密码\n\n\nrocketmq.config.aclEnabled： broker acl开启\n\n\nrocketmq.config.accessKey： broker acl账号\n\n\nrocketmq.config.secretKey： broker acl密码\n\nversion: &#x27;3.5&#x27;services:  rmqnamesrv:    image: apache/rocketmq:5.1.0    container_name: rmqnamesrv    restart: always    ports:      - 9876:9876    environment:      # 内存分配      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -server -Xms1g -Xmx1g&quot;    volumes:      - /data/rocketmq/namesrv/logs:/home/rocketmq/logs    command: [ &quot;sh&quot;, &quot;mqnamesrv&quot; ]    networks:      rmq:        aliases:          - rmqnamesrv  rmqbroker:    image: apache/rocketmq:5.1.0    container_name: rmqbroker    restart: always    depends_on:      - rmqnamesrv    ports:      - 10909:10909      - 10911:10911    volumes:      - /data/rocketmq/broker/logs:/root/logs      - /data/rocketmq/broker/store:/root/store      - /data/rocketmq/broker/conf/broker.conf:/home/rocketmq/broker.conf    command: [ &quot;sh&quot;, &quot;mqbroker&quot;, &quot;-c&quot;, &quot;/home/rocketmq/broker.conf&quot; ]    environment:      NAMESRV_ADDR: &quot;rmqnamesrv:9876&quot;      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -server -Xms1g -Xmx1g -Xmn1g&quot;    networks:      rmq:        aliases:          - rmqbroker  rmqdashboard:    image: apacherocketmq/rocketmq-dashboard:latest    container_name: rmqdashboard    restart: always    ports:      - 18080:8080    depends_on:      - rmqnamesrv    volumes:      - /etc/localtime:/etc/localtime:ro      - /home/rocketmq/console/data:/tmp/rocketmq-console/data    environment:      JAVA_OPTS: &quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876;rmqnamesrv1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false -Drocketmq.config.loginRequired=true&quot;    networks:      rmq:        aliases:          - rmqdashboardnetworks:  rmq:    name: rmq    driver: bridge\n\n集群docker-compose.yml参考version: &#x27;3.5&#x27;services:  rmqnamesrv:    image: apache/rocketmq:5.1.4    container_name: rmqnamesrv    restart: always    ports:      - 9876:9876    environment:      # 内存分配      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -server -Xms128m -Xmx128m&quot;    volumes:      - /home/rocketmq/namesrv/logs:/home/rocketmq/logs    command: [ &quot;sh&quot;, &quot;mqnamesrv&quot; ]    networks:      rmq:        aliases:          - rmqnamesrv  rmqnamesrv1:    image: apache/rocketmq:5.1.4    container_name: rmqnamesrv1    restart: always    ports:      - 9886:9876    environment:      # 内存分配      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -server -Xms128m -Xmx128m&quot;    volumes:      - /home/rocketmq/namesrv1/logs:/home/rocketmq/logs    command: [ &quot;sh&quot;, &quot;mqnamesrv&quot; ]    networks:      rmq:        aliases:          - rmqnamesrv1  rmqbroker:    image: apache/rocketmq:5.1.4    container_name: rmqbroker    restart: always    ports:      - 10909:10909      - 10911:10911    volumes:      - /home/rocketmq/broker/logs:/home/rocketmq/logs      - /home/rocketmq/broker/store:/home/rocketmq/store      - /home/rocketmq/broker/conf/broker.conf:/home/rocketmq/broker.conf    command: [ &quot;sh&quot;, &quot;mqbroker&quot;, &quot;-c&quot;, &quot;/home/rocketmq/broker.conf&quot; ]    environment:      NAMESRV_ADDR: &quot;rmqnamesrv:9876;rmqnamesrv1:9876&quot;      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -server -Xms128m -Xmx128m -Xmn128m&quot;    depends_on:      - rmqnamesrv      - rmqnamesrv1    networks:      rmq:        aliases:          - rmqbroker  rmqbroker1:    image: apache/rocketmq:5.1.4    container_name: rmqbroker1    restart: always    ports:      - 10919:10909      - 10921:10911    volumes:      - /home/rocketmq/broker1/logs:/home/rocketmq/logs      - /home/rocketmq/broker1/store:/home/rocketmq/store      - /home/rocketmq/broker1/conf/broker.conf:/home/rocketmq/broker.conf    command: [ &quot;sh&quot;, &quot;mqbroker&quot;, &quot;-c&quot;, &quot;/home/rocketmq/broker.conf&quot; ]    environment:      NAMESRV_ADDR: &quot;rmqnamesrv:9876;rmqnamesrv1:9876&quot;      JAVA_OPT_EXT: &quot;-Duser.home=/home/rocketmq -server -Xms128m -Xmx128m -Xmn128m&quot;    depends_on:      - rmqnamesrv      - rmqnamesrv1    networks:      rmq:        aliases:          - rmqbroker1  # 开启监控，并设置登录密码  rmqdashboard:    image: apacherocketmq/rocketmq-dashboard:latest    container_name: rmqdashboard    restart: always    ports:      - 18080:8080    volumes:      - /etc/localtime:/etc/localtime:ro      - /home/rocketmq/console/data:/tmp/rocketmq-console/data    environment:      JAVA_OPTS: &quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876;rmqnamesrv1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false -Drocketmq.config.loginRequired=true&quot;    depends_on:      - rmqnamesrv      - rmqnamesrv1    networks:      rmq:        aliases:          - rmqdashboardnetworks:  rmq:    name: rmq    driver: bridge\n\n常见问题：\n","categories":["docker"],"tags":["rocketMQ"]},{"title":"Sentinel部署 ( docker )","url":"/2022/02/14/Sentinel%E9%83%A8%E7%BD%B2%20(%20docker%20)%20/","content":"\n由于Sentinel官方并没有提供相对应的docker官方镜像，为了方便容器环境下使用，我们使用官方提供的sentinel jar包制作sentinel dashboard的docker镜像， 并将镜像发布到dockerhub方便使用sentinel的镜像。\n示例版本为1.8.3\n\n下载官方jar包, 并上传服务器\nSentinel\n\n创建Sentinel的Dockerfile镜像制作脚本###########sentinel dashboard的Dockerfile镜像脚本##########引入依赖的java环境FROM openjdk:8-alpine3.9 #工作环境变量配置ENV SENTINEL_HOME=/opt/sentinel#版本环境变量配置 这里配置版本为下载的版本ENV SENTINEL_DASHBOARD_VERSION=1.8.3 CMD [&quot;/bin/bash&quot;] #工作目录WORKDIR $&#123;SENTINEL_HOME&#125; #作者信息MAINTAINER Matt &lt;myismatt@foxmail.com&gt; #添加sentinel dashboard镜像源ADD sentinel-dashboard-$&#123;SENTINEL_DASHBOARD_VERSION&#125;.jar $&#123;SENTINEL_HOME&#125;/sentinel-dashboard-$&#123;SENTINEL_DASHBOARD_VERSION&#125;.jar #暴露端口EXPOSE 8080 #启动命令ENTRYPOINT java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-$&#123;SENTINEL_DASHBOARD_VERSION&#125;.jar\n\n编译脚本docker build -f Dockerfile -t sentinel-dashboard:1.8.3 .\n\n编写docker-compose.ymlversion: &#x27;3&#x27;services: sentinel:    image: sentinel-dashboard:1.8.3    container_name: sentinel    restart: always    privileged: true    ports:        - 8858:8858\n启动docker-compose up -d\n\n","categories":["docker"],"tags":["sentinel"]},{"title":"nginx部署 ( docker )","url":"/2022/01/12/nginx%E9%83%A8%E7%BD%B2%20(%20docker%20)/","content":"拉取镜像docker pull nginx:1.19.8\n\n创建关联文件#创建文件夹mkdir /data/&#123;conf,conf.d,html,logs&#125;#编辑nginx.conf配置 配置内容在文后cd confvi nginx.conf#编辑default.conf配置 配置内容在文后cd conf.dvi default.conf\n\n\n\n创建docker-compose.ymlversion: &#x27;3&#x27;services:  nginx:    # 镜像名    image: nginx:1.19.8    # 容器名    container_name: matt-nginx    # 重启策略    restart: always    privileged: true        # 端口映射    ports:      - 80:80                      - 8080:8080    # 挂载目录     volumes:      - /home/docker-container/nginx/conf/nginx.conf:/etc/nginx/nginx.conf      - /home/docker-container/nginx/conf.d:/etc/nginx/conf.d      - /home/docker-container/nginx/html:/usr/share/nginx/html      - /home/docker-container/nginx/logs:/var/log/nginx    environment:        - TZ=Asia/Shanghai\n\n启动\n将需要代理的前端vue项目放入html文件夹中, 在conf.d文件夹中加入nginx配置文件,重启nginx即可\n\ndocker-compose up -d\n\nnginx.confuser  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;&#125;\n\ndefault.confserver &#123;    listen       80;    server_name  localhost;    #charset koi8-r;    #access_log  /var/log/nginx/host.access.log  main;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;&#125;\n\nnginx代理配置文件示例server &#123;    listen       8080;    server_name  127.0.0.1;    location / &#123;        #此处填写的地址是docker容器的html地址,因为我们已经做了挂载,例如宿主机/data/nginx/html/demo,则下面root应该填写/usr/share/nginx/html/demo        root  /usr/share/nginx/html/demo;        try_files $uri $uri/ /index.html;        index  index.html index.htm;    &#125;    location /api/&#123;\t\tproxy_set_header Host $http_host;\t\tproxy_set_header X-Real-IP $remote_addr;\t\tproxy_set_header REMOTE-HOST $remote_addr;\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t\tproxy_pass http://172.19.20.129:8090/;    &#125; &#125;\n\n","categories":["docker"],"tags":["nginx"]},{"title":"CentOS7.X离线安装docker","url":"/2022/11/22/installation/CentOS7.X%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/","content":"第一种下载docker的安装包docker安装包需要的依赖:\n\ndocker-ce-cli\ncontainerd.io\ncontainer-selinux\n\n执行安装命令\n先安装依赖再安装docker\n\nrpm -ivh docker-ce-cli-24.0.4-1.el7.x86_64.rpmrpm -ivh container-selinux-2.119.2-1.911c772.el7_8.noarch.rpmrpm -ivh containerd.io-1.6.9-3.1.el7.x86_64.rpm      rpm -ivh docker-ce-24.0.4-1.el7.x86_64.rpm\n\n启动# 启动systemctl start docker # 查看状态systemctl status docker # 开启docker开机自启动systemctl enable docker.service\n\n第二种下载上传安装文件并解压安装docker下载\n将解压出来的docker文件复制到 /usr/bin/ 目录下cp docker/* /usr/bin/\n\n进入/etc/systemd/system/目录,并创建docker.service文件cd /etc/systemd/system/touch docker.service\n\n打开docker.service文件,将以下内容复制 注意： –insecure-registry=192.168.200.128 此处改为你自己服务器ip[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=192.168.200.128ExecReload=/bin/kill -s HUP $MAINPID# Having non-zero Limit*s causes performance problems due to accounting overhead# in the kernel. We recommend using cgroups to do container-local accounting.LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity# Uncomment TasksMax if your systemd version supports it.# Only systemd 226 and above support this version.#TasksMax=infinityTimeoutStartSec=0# set delegate yes so that systemd does not reset the cgroups of docker containersDelegate=yes# kill only the docker process, not all processes in the cgroupKillMode=process# restart the docker process if it exits prematurelyRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.target\n\n给docker.service文件添加执行权限chmod 777 /etc/systemd/system/docker.service \n\n重新加载配置文件（每次有修改docker.service文件时都要重新加载下）systemctl daemon-reload \n\n启动配置# 启动systemctl start docker# 设置开机启动systemctl enable docker.service# 查看状态systemctl status docker","categories":["docker"],"tags":["docker","centos","linux"]},{"title":"CentOS在线安装Docker,Docker-Compose","url":"/2019/11/15/installation/CentOS%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85Docker,Docker-Compose/","content":"Docker安装安装依赖包sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n\n设置阿里云镜像源sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n安装 Docker-CEsudo yum install docker-ce\n\n注意事项如果操作失败了# 1、查看安装过的docker：yum list installed | grep dockerdocker.x86_64                           2:1.13.1-74.git6e3bb8e.el7.centosdocker-client.x86_64                    2:1.13.1-74.git6e3bb8e.el7.centosdocker-common.x86_64                    2:1.13.1-74.git6e3bb8e.el7.centos# 2、卸载docker：sudo yum remove -y docker-ce.x86_64 docker-client.x86_64 docker-common.x86_64# 3、删除容器镜像：sudo rm -rf /var/lib/docker# 4、 重新安装dockersudo yum install docker-ce\n\n安装rsyncyum -y install rsync  #启动rsync服务systemctl start rsyncd.servicesystemctl enable rsyncd.service#检查是否已经成功启动netstat -lnp|grep 873\n\n迁移工作目录#将docker的工作迁移至我们指定的目录,一般迁移到数据盘,防止服务器宕机或者数据丢失,这里迁移至我们挂载的数据盘data目录# 先关闭 Docker 服务:systemctl stop docker# 然后复制文件到新目录rsync -avz /var/lib/docker/ /data/docker/#创建修改daemon.jsonsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;data-root&quot;:&quot;/data/docker&quot;&#125;EOF\n\n开启开机启动# 开机自启sudo systemctl enable docker # 启动docker服务  sudo systemctl start docker\n\n配置镜像加速(以阿里云为例)# 加速器地址:# 阿里云控制台搜索容器镜像服务# 进入容器镜像服务， 左侧最下方容器镜像服务中复制加速器地址vim  /etc/docker/daemon.json#增加registry-mirrors&#123;    &quot;data-root&quot;:&quot;/data/docker&quot;,    &quot;registry-mirrors&quot;: [&quot;https://v783q8oj.mirror.aliyuncs.com&quot;]&#125;# 重启dockersudo systemctl daemon-reloadsudo systemctl restart docker\n\nDocker-Compose安装docker-compose下载地址\n#前往下载地址下载合适的docker-compose,上传至目录/usr/local/bin/#也可以直接curl -L直接下载#给docker-compose执行权限chmod +x /usr/local/bin/docker-compose#查看版本docker-compose --version#出现下面内容就成功了[root@]# docker-compose --versiondocker-compose version 1.27.4, build 40524192\n\n关于开放docker端口\n出于安全性考虑不建议开启\n\nvim /usr/lib/systemd/system/docker.service#找到下面这段[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=always在ExecStart=/usr/bin/dockerd 后插入 -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock#建议修改docker默认端口2375防止被攻击#重启虚拟机systemctl daemon-reload #重启dockersystemctl restart docker\n\ndocker命令#在首次执行 尽量使用 这样可以看到报错docker-compose --compatibility up","categories":["docker"],"tags":["docker"]},{"title":"Elasticsearch7.X安装（docker）","url":"/2023/08/23/installation/Elasticsearch7.X%E5%AE%89%E8%A3%85%EF%BC%88docker%EF%BC%89/","content":"Elasticsearch7.X安装单机模式创建挂载目录文件夹mkdir -p /home/elasticsearch/&#123;config,data,plugins&#125;\n\n授权文件夹(不然无法启动)chmod 777 /home/elasticsearch/*\n\n编写docker-compose.yml文件version: &#x27;3.5&#x27;services:  es0:    # 镜像名    image: elasticsearch:7.17.8    # 容器名    container_name: dev-es0-19200-19300    # 重启策略    restart: unless-stopped    privileged: true    environment:      # 单机模式      - discovery.type=single-node      # 配置内存,不然占用会非常大      - ES_JAVA_OPTS=-Xms512m -Xmx512m    # 端口映射    ports:      - 19200:9200      - 19300:9300    volumes:      - /home/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml      - /home/elasticsearch/data:/usr/share/elasticsearch/data      - /home/elasticsearch/plugins:/usr/share/elasticsearch/plugins# 根据现有docker network配置networks:  default:    external:      name: dev\n\nEs8 的docker配置version: &#x27;3.5&#x27;services:  es0:    # 镜像名    image: elasticsearch:8.12.2    # 容器名    container_name: es8-19200-19300    # 重启策略    restart: unless-stopped    privileged: true    environment:      # 单机模式      - discovery.type=single-node      # 配置内存,不然占用会非常大      - ES_JAVA_OPTS=-Xms102m -Xmx1024m    # 端口映射    ports:      - 19200:9200      - 19300:9300    volumes:      - /home/elasticsearch8/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml      - /home/elasticsearch8/data:/usr/share/elasticsearch/data      - /home/elasticsearch8/plugins:/usr/share/elasticsearch/plugins\n\nelasticsearch.ymlhttp.host: 0.0.0.0http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;","categories":["elasticsearch"],"tags":["docker","elasticsearch"]},{"title":"Redis安装 ( docker )","url":"/2020/10/06/installation/Redis%E5%AE%89%E8%A3%85%20(%20docker%20)/","content":"拉取镜像docker pull redis:6.0.9\n创建配置文件mkdir -p /home/redis/data /home/redis/conf\n编写redis.conf配置文件# 修改连接为所有ipbind 0.0.0.0# 允许外网访问protected-mode noport 6379timeout 0# RDB存储配置save 900 1save 300 10save 60 10000rdbcompression yesdbfilename dump.rdb# 数据存放位置dir /data# 开启aof配置appendonly yesappendfsync everysecappendfilename &quot;appendonly.aof&quot;# 设置密码requirepass 123456\n编写docker-compose.ymlversion: &#x27;3.8&#x27;networks:  my_network:    external: true    name: xc-networkservices:  redis-26379:    # 镜像名    image: redis:7.2.4    # 容器名    container_name: redis-26379    # 重启策略    restart: always    privileged: true      networks:      - my_network    # 端口映射    ports:      - 26379:6379    environment:      # 设置环境变量 时区上海 编码UTF-8      TZ: Asia/Shanghai      LANG: en_US.UTF-8    volumes:      # 配置文件      - /mnt/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf      # 数据文件      - /mnt/redis/data:/data    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]","categories":["docker"],"tags":["redis"]},{"title":"Ubuntu离线安装Docker","url":"/2023/07/12/installation/Ubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Docker/","content":"下载下载路径：https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/\n\n下载版本离线安装docker需要下载3个包，containerd.io ，docker-ce-cli，docker-ce\ncontainerd.io_1.2.6-3_amd64.deb\ndocker-ce_19.03.9_3-0_ubuntu-xenial_amd64.deb\ndocker-ce-cli_19.03.9_3-0_ubuntu-xenial_amd64.deb\n\n安装\n下载完毕后拷贝到ubuntu上用 dpkg 命令安装，安装顺序：先安装 containerd.io 跟 docker-ce-cli，最后安装docker-ce，命令：sudodpkg-i xxxx.deb依次执行安装，顺序不能改变\n\ndpkg -i containerd.io_1.2.6-3_amd64.debdpkg -i docker-ce-cli_19.03.9_3-0_ubuntu-xenial_amd64.debdpkg -i docker-ce_19.03.9_3-0_ubuntu-xenial_amd64.deb\n\n启动systemctl start docker\nsystemctl status docker \n\n设置自启动# 设置 docker自动启动\nsystemctl enable docker.service\n# 查看docker 在系统中状态\nsystemctl list-unit-files |grep docker\n\n设置加速# 添加加速镜像cd /etcmkdir docker cd /etc/dockervim daemon.json# 将下面复制到daemon.json文件中 https://registry.docker-cn.com&#123; &quot;registry-mirrors&quot;: [&quot;https://81zkznk0.mirror.aliyuncs.com&quot;]&#125;# 重启dockersystemctl restart docker.service","categories":["docker"],"tags":["docker","linux","ubuntu"]},{"title":"docker-compose部署安装gitlab","url":"/2023/06/28/installation/docker-compose%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85gitlab/","content":"拉取镜像docker pull gitlab/gitlab-ce:nightly\n\n编写docker-compose.ymlversion: &#x27;3.5&#x27;services:  gitlab:    # 镜像名    image: gitlab/gitlab-ce:nightly    # 容器名    container_name: test-gitlab    # 重启策略    restart: unless-stopped    privileged: true    environment:      TZ: &#x27;Asia/Shanghai&#x27;      GITLAB_OMNIBUS_CONFIG: |        # #gitlab访问地址，可以写域名。如果端口不写的话默认为80端口        external_url &#x27;http://labs.test.com:2333&#x27;        # #ssh主机ip        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 1022        gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;        # 头像图片处理        #gitlab_rails[&#x27;gravatar_plain_url&#x27;] = &#x27;http://sdn.geekzu.org/avatar/%&#123;hash&#125;?s=%&#123;size&#125;&amp;d=identicon&#x27;        gitlab_rails[&#x27;gravatar_ssl_url&#x27;] = &#x27;https://seccdn.libravatar.org/avatar/%&#123;hash&#125;?s=%&#123;size&#125;&amp;d=identicon&#x27;        gitlab_rails[&#x27;backup_path&#x27;] = &quot;/var/opt/gitlab/backups&quot;        # 是否开启nginx代理 此处必须true        nginx[&#x27;enable&#x27;] = true        # https配置根据实际需求来配置, 如果是转发的https则可以不配置        nginx[&#x27;redirect_http_to_https&#x27;] = false        nginx[&#x27;ssl_prefer_server_ciphers&#x27;] = &quot;off&quot;        #nginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/labs.test.com.pem&quot;        #nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/labs.test.com.key&quot;    # 端口映射    ports:      - 2333:2333   # 此处端口号须与 external_url 中保持一致，左边和右边都要一样          - 443:443      - 1022:22     # 这里的1022和上面的1022一致，但是右边必须是22，不能是其他    volumes:      - /home/gitlab/config:/etc/gitlab      - /home/gitlab/logs:/var/log/gitlab      - /home/gitlab/data:/var/opt/gitlab      - /home/gitlab/backups:/var/opt/gitlab/backups      # 该目录下面有初始密码      - /home/gitlab/etc:/etc/gitlabnetworks:  default:    external: true    name: test\n\n修改root密码# 进入容器内部docker exec -it gitlab /bin/bash# 进入控制台gitlab-rails console -e production# 查询id为1的用户，id为1的用户是超级管理员user = User.where(id:1).first# 修改密码为pdl123456user.password=&#x27;pdl123456&#x27;# 保存user.save!# 退出exit\n\n问题初始密码在/etc/gitlab目录下面int_password\n\n#日志报错Failed to get final advertise address: No private IP address found, and explicit IP not provided在 /etc/gitlab/gitlab.rb文件末尾追加配置\n   alertmanager[&#x27;flags&#x27;] = &#123;   &#x27;cluster.advertise-address&#x27; =&gt; &quot;127.0.0.1:9093&quot;,&#125;","categories":["docker"],"tags":["git"]},{"title":"安装jenkins并配置jdk,maven,git ( docker )","url":"/2019/09/01/installation/%E5%AE%89%E8%A3%85jenkins%E5%B9%B6%E9%85%8D%E7%BD%AEjdk,maven,git%20(%20docker%E7%89%88%E6%9C%AC%20)/","content":"\n前置条件先安装好docker,docker-compose,jdk,maven,git在宿主机上\n\n拉取镜像docker pull jenkinsci/blueocean:1.24.8\n\n创建挂载文件目录mkdir /home/jenkins_home\n\n编写docker-compose.ymlversion: &#x27;3.5&#x27;services:  jenkins:    user: root    image: jenkinsci/blueocean:1.24.8    container_name: jenkins    restart: always    ports:      - 7070:8080      - 50000:50000    #目录挂载    volumes:    #挂载jenkinshome      - /home/jenkins_home:/var/jenkins_home    #挂载maven      - /home/maven/apache-maven-3.8.2:/usr/local/maven    #挂载jkd      - /home/jdk1.8/jdk1.8.0_261:/usr/local/jdk8    #挂载git        - /usr/local/git:/usr/local/git\n启动docker-composedocker-compose up -d \n\n打开jenkins安装相关插件git, maven\n\n","categories":["docker"],"tags":["jenkins"]},{"title":"Mybatis-Plus自定义sql如何添加id","url":"/2024/04/12/java/Mybatis-Plus%E8%87%AA%E5%AE%9A%E4%B9%89sql%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0id/","content":"\n一直使用Mybatis-Plus，但是自定义sql时，发现没有id，所以记录一下\n\n我有一个需求是需要在inser数据的时候检查是否存在，存在就更新数据，不存在就插入数据，所以自己写了一个upsert语句如下：\n&lt;insert id=&quot;insertOrUpdateNewsBody&quot; parameterType=&quot;com.easy.dataCenter.bean.pojo.AiNewsBody&quot;           useGeneratedKeys=&quot;true&quot;&gt;       INSERT INTO `test` (`id`,`news_id`, `news_publish_time`, `news_publish_site`,`news_title`, `news_body`,       `quota`, `news_message_id`,`news_store_time`, `create_time`)       VALUES (       $&#123;@com.baomidou.mybatisplus.core.toolkit.IdWorker@getId()&#125;,       #&#123;newsBody.newsId&#125;,       #&#123;newsBody.newsPublishTime&#125;,       #&#123;newsBody.newsPublishSite&#125;,       #&#123;newsBody.newsTitle&#125;,       #&#123;newsBody.newsBody&#125;,       #&#123;newsBody.quota&#125;,       #&#123;newsBody.newsMessageId&#125;,       #&#123;newsBody.newsStoreTime&#125;,       #&#123;newsBody.createTime&#125;)       ON DUPLICATE KEY UPDATE       &lt;if test=&quot;newsBody.newsPublishTime != null and newsBody.newsPublishTime != &#x27;&#x27;&quot;&gt;           `news_publish_time` = #&#123;newsBody.newsPublishTime&#125;,       &lt;/if&gt;       &lt;if test=&quot;newsBody.newsPublishSite != null and newsBody.newsPublishSite != &#x27;&#x27;&quot;&gt;           `news_publish_site` = #&#123;newsBody.newsPublishSite&#125;,       &lt;/if&gt;       &lt;if test=&quot;newsBody.newsTitle != null and newsBody.newsTitle != &#x27;&#x27;&quot;&gt;           `news_title` = #&#123;newsBody.newsTitle&#125;,       &lt;/if&gt;       &lt;if test=&quot;newsBody.newsBody != null and newsBody.newsBody != &#x27;&#x27;&quot;&gt;           `news_body`=#&#123;newsBody.newsBody&#125;,       &lt;/if&gt;       &lt;if test=&quot;newsBody.quota != null and newsBody.quota != &#x27;&#x27;&quot;&gt;           `quota` = #&#123;newsBody.quota&#125;       &lt;/if&gt;   &lt;/insert&gt;\n因为这里需要使用到id，所以需要自己生成id，但是发现生成的id是0，所以需要修改一下，修改如下：\n使用  $&#123;@com.baomidou.mybatisplus.core.toolkit.IdWorker@getId()&#125; 来代替id字段的值，这样就实现了使用mybatis-plus自带的id生成策略\n\n","categories":["mybatis"],"tags":["Mybatis-Plus"]},{"title":"Mybatis实现一对多的查询方式","url":"/2020/10/06/java/Mybatis%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F/","content":"\nmybatis 实现一对多的查询方式\n\npackage com.sgcc.demo.model.bo;/**   * @author liyalong * @description //TODO  * @date 13:44 2019/12/2 **/import com.sgcc.demo.model.po.DemoFileInfo;import com.sgcc.demo.model.po.DemoFileManagement;import lombok.Data;import java.util.List;@Datapublic class DemoFileManagementBo extends DemoFileManagement &#123;    // 文件list    private List&lt;DemoFileInfo&gt; fileInfos;&#125;\n第一种 （适合单条查询一对多）\n这种方式仅适合于 查询一条信息，或者多条信息不使用PageQuery进行分页的情况下。（效率比较快，然是局限性比较强）\n\n&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.sgcc.demo.model.po.DemoFileManagement&quot;&gt;       &lt;id column=&quot;GUID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;guid&quot;/&gt;       &lt;result column=&quot;NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;       &lt;result column=&quot;VERSION&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;version&quot;/&gt;       &lt;result column=&quot;REMARK&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;remark&quot;/&gt;       &lt;result column=&quot;UPDATE_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot;/&gt;       &lt;result column=&quot;DELETE_FLG&quot; jdbcType=&quot;CHAR&quot; property=&quot;deleteFlg&quot;/&gt;   &lt;/resultMap&gt;   &lt;resultMap id=&quot;fileMap&quot; type=&quot;com.sgcc.demo.model.po.DemoFileInfo&quot;&gt;       &lt;id column=&quot;GUID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;guid&quot;/&gt;       &lt;result column=&quot;INFO_ID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;infoId&quot;/&gt;       &lt;result column=&quot;FILE_NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fileName&quot;/&gt;       &lt;result column=&quot;FILE_ADDRESS&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fileAddress&quot;/&gt;       &lt;result column=&quot;CREATE_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&gt;   &lt;/resultMap&gt;   &lt;select id=&quot;selectById&quot; resultMap=&quot;productsListMap&quot; parameterType=&quot;string&quot;&gt;       select       a.GUID,       a.VERSION,       a.REMARK,       a.UPDATE_TIME,       a.NAME,       b.GUID as file_GUID,       b.FILE_NAME,       b.FILE_ADDRESS,       b.CREATE_TIME       from demo_file_management a       left join demo_file_info b on a.GUID = b.INFO_ID       &lt;where&gt;           a.DELETE_FLG = &#x27;0&#x27;           &lt;if test=&quot;id != null and id != &#x27;&#x27;&quot;&gt;               and a.GUID = #&#123;id&#125;           &lt;/if&gt;       &lt;/where&gt;   &lt;/select&gt;\n第二种方式（适用于分页查询）\n采用两套查询，主查询和子查询进行配合（缺点就是，效率不如第一种，但是可以分页使用，不限制连表方式）。\n\n&lt;resultMap id=&quot;productsListMap&quot; type=&quot;com.sgcc.demo.model.bo.DemoFileManagementBo&quot; extends=&quot;BaseResultMap&quot;&gt;      &lt;collection property=&quot;fileInfos&quot;  ofType=&quot;com.sgcc.demo.model.po.DemoFileInfo&quot;&gt;          &lt;id column=&quot;file_GUID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;guid&quot;/&gt;          &lt;result column=&quot;INFO_ID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;infoId&quot;/&gt;          &lt;result column=&quot;FILE_NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fileName&quot;/&gt;          &lt;result column=&quot;FILE_ADDRESS&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fileAddress&quot;/&gt;          &lt;result column=&quot;CREATE_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&gt;      &lt;/collection&gt;  &lt;/resultMap&gt;  &lt;resultMap id=&quot;productsListMap1&quot; type=&quot;com.sgcc.demo.model.bo.DemoFileManagementBo&quot;&gt;      &lt;id column=&quot;GUID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;guid&quot;/&gt;      &lt;result column=&quot;NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;      &lt;result column=&quot;VERSION&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;version&quot;/&gt;      &lt;result column=&quot;REMARK&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;remark&quot;/&gt;      &lt;result column=&quot;UPDATE_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot;/&gt;      &lt;result column=&quot;DELETE_FLG&quot; jdbcType=&quot;CHAR&quot; property=&quot;deleteFlg&quot;/&gt;      &lt;collection property=&quot;fileInfos&quot; ofType=&quot;com.sgcc.demo.model.po.DemoFileInfo&quot; select=&quot;selectFileList&quot; column=&quot;GUID&quot;/&gt;  &lt;/resultMap&gt;  &lt;!--主查询--&gt;  &lt;select id=&quot;select&quot; resultMap=&quot;productsListMap1&quot; parameterType=&quot;com.sgcc.demo.model.po.DemoFileManagement&quot;&gt;      select      a.GUID,      a.VERSION,      a.REMARK,      a.UPDATE_TIME,      a.NAME      from demo_file_management a      &lt;where&gt;          a.DELETE_FLG = &#x27;0&#x27;          &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;              and a.NAME LIKE concat(&quot;%&quot;,#&#123;name&#125;,&quot;%&quot;)          &lt;/if&gt;      &lt;/where&gt;      Order by  a.UPDATE_TIME desc  &lt;/select&gt;  &lt;!--  子查询  --&gt;  &lt;select id=&quot;selectFileList&quot; resultType=&quot;com.sgcc.demo.model.po.DemoFileInfo&quot;&gt;      select          b.GUID as guid,          b.FILE_NAME as fileName,          b.FILE_ADDRESS as fileAddress,          b.CREATE_TIME as createTime      from          demo_file_info b      where          b.INFO_ID = #&#123;guid&#125;  &lt;/select&gt;","categories":["mybatis"],"tags":["mybatis"]},{"title":"mysql文件上传下载  vue下载","url":"/2021/09/06/java/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%9C%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93,vue%E4%B8%8B%E8%BD%BD/","content":"\nJAVA文件以流的形式存在Mysql(blob)数据库,mysql最大支持4G文件(longblb)\n\n直接将流转换为byte存入数据库public Response uploadBlob(MultipartFile file) &#123;    //数据库实体类 改成自己的    FileUpload fileUpload = new FileUpload();    fileUpload.setFileName(file.getOriginalFilename());    try &#123;        fileUpload.setContent(FileTypeUtils.input2byte(file.getInputStream()));    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    save(fileUpload);    return Response.ok(&quot;成功&quot;, fileUpload.getId());&#125;/** * 将 流 转换为byte * * @param inStream * @return * @throws IOException */public static byte[] input2byte(InputStream inStream) throws IOException &#123;    try (ByteArrayOutputStream swapStream = new ByteArrayOutputStream()) &#123;        byte[] buff = new byte[inStream.available()];        while (inStream.read(buff) != -1) &#123;            swapStream.write(buff);        &#125;        return swapStream.toByteArray();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return null;&#125;\n\n下载文件输出文件流到前端public void getFile(String id, HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException &#123;       // 获取数据库文件信息       FileUpload fileUpload = getById(id);       if (fileUpload.getContent() != null) &#123;           //获取存储的文件名称           String filename = fileUpload.getFileName();           //获取浏览器版本           String userAgent = request.getHeader(&quot;USER-AGENT&quot;);           //IE浏览器           if (StringUtils.contains(userAgent, &quot;MSIE&quot;)) &#123;               filename = URLEncoder.encode(filename, &quot;UTF8&quot;);           &#125;           //google,火狐浏览器           else if (StringUtils.contains(userAgent, &quot;Mozilla&quot;)) &#123;               filename = new String(filename.getBytes(), &quot;ISO8859-1&quot;);           &#125;           //其他浏览器           else &#123;               filename = URLEncoder.encode(filename, &quot;UTF8&quot;);           &#125;           try &#123;               byte[] fileStream = fileUpload.getContent();               response.setHeader(&quot;content-type&quot;, &quot;application/octet-stream&quot;);               //这边可以设置文件下载时的名字，我这边用的是文件原本的名字，可以根据实际场景设置               response.setContentType(&quot;application/octet-stream&quot;);               response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(filename, &quot;UTF-8&quot;));               OutputStream toClient = new BufferedOutputStream(response.getOutputStream());               toClient.write(fileStream);               toClient.flush();               toClient.close();           &#125; catch (Exception e) &#123;               e.printStackTrace();           &#125;       &#125;   &#125;\n流的方式前端要指定  responseType: ‘blob’methods: &#123;   downLoad() &#123;     if (this.fileId) &#123;       request(&#123;         url: &quot;localhost:8080/file/getFile&quot;,         method: &quot;get&quot;,         params: &#123; id: this.fileId &#125;,         //指定 responseType         responseType: &#x27;blob&#x27;       &#125;).then((resp) =&gt; &#123;         let blob = new Blob([resp],&#123;           type:&#x27;application/vnd.ms-excel&#x27;         &#125;);         let objectUrl = URL.createObjectURL(blob);  //生成一个url         this.downloadFile(objectUrl,this.form.fileName)       &#125;);     &#125;   &#125;&#125;\n\n\n转成文件public File getFile(String id, HttpServletRequest request, HttpServletResponse response) &#123;      // 获取数据库文件信息      FileUpload fileUpload = getById(id);      if (fileUpload.getContent() != null) &#123;          File file = null;          try &#123;              file = new File(fileUpload.getFileName());              if (!file.exists()) &#123;                  file.createNewFile();              &#125;              OutputStream os = new FileOutputStream(file);              os.write(fileUpload.getContent());              os.close();          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;          return file;      &#125;  &#125;","categories":["java"],"tags":["文件上传下载","数据库"]},{"title":"mysql主从复制 ( docker-compose )","url":"/2024/04/02/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","content":"mysql主从复制\nMySQL 主从复制是一种基于日志的复制机制，用于将主服务器（Master）上的数据实时复制到一个或多个从服务器（Slave）。主从复制的原理如下： \n\n主服务器将所有修改操作记录在二进制日志（Binary Log）中。这些修改可以是插入、更新或删除数据的操作。\n从服务器连接到主服务器，并发送一个请求，请求成为主服务器的从服务器。主服务器收到请求后，将记录从服务器的信息，并开始与从服务器建立复制连接。\n主服务器将二进制日志中的内容发送给从服务器。从服务器接收并执行这些日志中的操作，将数据修改操作反映到自己的数据库上。 \n从服务器还会定期向主服务器发送心跳信息以维持连接。如果主服务器长时间没有收到从服务器的心跳信息，就认为从服务器宕机，不再向其发送日志。 \n如果主服务器发生故障，导致无法提供服务，可以将一个从服务器提升为新的主服务器，以继续提供服务。此时，其他从服务器将切换到新的主服务器上进行复制。 \n通过主从复制，可以实现数据的实时复制和分布式读取，提高数据库的可用性和读取性能。此外，主从复制还可以用于备份数据，当主服务器发生故障时，可以快速切换到从服务器，减少服务停机时间。 \n需要注意的是，主从复制是异步的，从服务器的数据可能稍有延迟。而且主从复制只复制数据修改操作，不复制表结构的变更。如果需要同步表结构的变更，可以使用主从复制搭配其他工具，如 GTID（Global Transaction Identifier）或者基于触发器的解决方案。\n\n\n创建对应的文件夹  mkdir -p /home/mysql/&#123;cnf,logs,mysql&#125;\n  mkdir -p /home/mysql-slave/&#123;cnf,logs,mysql&#125;\n\n在cnf文件夹下创建my.cnf文件#写入下面配置[mysqld]pid-file\t= /var/run/mysqld/mysqld.pidsocket\t\t= /var/run/mysqld/mysqld.sockdatadir\t\t= /var/lib/mysqldefault-time_zone=&#x27;+8:00&#x27;skip-name-resolvelog-bin=mysql-binbinlog-format=ROW# 每个服务不一样server_id=1symbolic-links=0expire_logs_days=7max_connections = 2000max_user_connections = 1900max_connect_errors = 100000max_allowed_packet = 50Mlower_case_table_names=0sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;\n\n编写docker-compose.yml文件version: &#x27;3.5&#x27;networks:  mysql-network:    driver: bridge    ipam:      config:        - subnet: 10.1.20.0/24services:  mysql-master:    image: mysql:8.0.32    container_name: mysql-3124    privileged: true    restart: always    ports:      - 3124:3306    environment:      - TZ=Asia/Shanghai      - MYSQL_ROOT_PASSWORD=L3z5uLD@rB1y      - character-set-server=utf8mb4      - collation-server=utf8mb4_general_ci    #目录挂载    volumes:      - /home/mysql/cnf:/etc/mysql/conf.d      - /home/mysql/logs:/logs       - /home/mysql/mysql:/var/lib/mysql    networks:      mysql-network:        ipv4_address: 10.1.20.2  mysql-slave:    image: mysql:8.0.32    container_name: mysql-3125    privileged: true    restart: always    ports:      - 3125:3306    environment:      - TZ=Asia/Shanghai      - MYSQL_ROOT_PASSWORD=L3z5uLD@rB1y      - character-set-server=utf8mb4      - collation-server=utf8mb4_general_ci    #目录挂载    volumes:      - /home/mysql-slave/cnf:/etc/mysql/conf.d      - /home/mysql-slave/logs:/logs       - /home/mysql-slave/mysql:/var/lib/mysql    networks:      mysql-network:        ipv4_address: 10.1.20.3","categories":["docker"],"tags":["mysql"]},{"title":"mysql安装 ( docker )","url":"/2022/11/08/mysql/mysql%E5%AE%89%E8%A3%85%20(%20docker%20)%20/","content":"Mysql5.X安装拉取镜像docker pull  mysql:5.7.31\n\n创建挂载文件mkdir /data/mysql/&#123;cnf,logs,mysql&#125;\n\n创建配置文件vi /data/mysql/cnf/my.cnf\n\n#写入下面配置[mysqld]pid-file\t= /var/run/mysqld/mysqld.pidsocket\t\t= /var/run/mysqld/mysqld.sockdatadir\t\t= /var/lib/mysqllog-error\t= /var/log/mysql/error.logdefault-time_zone=&#x27;+8:00&#x27;skip-name-resolvelog-bin=mysql-binbinlog-format=ROWserver_id=2symbolic-links=0expire_logs_days=7max_connections = 2000max_user_connections = 1900max_connect_errors = 100000max_allowed_packet = 50Mlower_case_table_names=0sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;[client]default-character-set=utf8[mysql]character-set-server=utf8\n\n编写docker-compose文件version: &#x27;3.5&#x27;services:  web:    image: mysql:5.7.31    container_name: mysql-5.7.31    restart: always    ports:      - 3306:3306    environment:      - TZ=Asia/Shanghai      - MYSQL_ROOT_PASSWORD=root      #目录挂载    volumes:      - /data/mysql/conf:/etc/mysql/conf.d      - /data/mysql/logs:/logs       - /data/mysql/mysql:/var/lib/mysql\n\n启动docker-compose up -d\n#查看日志\ndocker-compose logs -f \n\n配置远程访问#进入mysql容器\ndocker exec -it mysql-5.7.31 bash\n#登录mysql\nmysql -uroot -proot\n#创建用户并添加权限\ngrant all privileges on 库名.* to 登录名@&#39;%&#39; identified by &#39;123456&#39;;\n#刷新mysql权限\nFLUSH PRIVILEGES;\n#退出\nexit;\n\nMysql8.X安装拉取镜像docker pull mysql:8.0.31\n\n创建挂载文件mkdir /data/mysql/&#123;cnf,logs,mysql&#125;\n\n创建配置文件vi /data/mysql/cnf/my.cnf\n\n#写入下面配置[mysqld]pid-file\t= /var/run/mysqld/mysqld.pidsocket\t\t= /var/run/mysqld/mysqld.sockdatadir\t\t= /var/lib/mysqldefault-time_zone=&#x27;+8:00&#x27;skip-name-resolvelog-bin=mysql-binbinlog-format=ROWserver_id=1symbolic-links=0expire_logs_days=7max_connections = 2000max_user_connections = 1900max_connect_errors = 100000max_allowed_packet = 50Mlower_case_table_names=0sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;\n\n编写docker-compose文件version: &#x27;3.5&#x27;services:  mysql-3310:    image: mysql:8.0.31    container_name: mysql-3310    privileged: true    restart: always    ports:      - 3310:3306    environment:      - TZ=Asia/Shanghai      - MYSQL_ROOT_PASSWORD=root      - character-set-server=utf8mb4      - collation-server=utf8mb4_general_ci    #目录挂载    volumes:      - /data/mysql/cnf:/etc/mysql/conf.d      - /data/mysql/logs:/logs       - /data/mysql/mysql:/var/lib/mysql\n\n启动docker-compose up -d\n# 查看日志\ndocker-compose logs -f \n\n配置远程访问# 进入mysql容器\ndocker exec -it mysql-5.7.31 bash\n# 登录mysql\nmysql -uroot -proot\n\n# 在mysql8.0创建用户和授权和之前不太一样了，其实严格上来讲，也不能说是不一样,只能说是更严格,mysql8.0需要先创建用户和设置密码,然后才能授权. \n# 先创建一个用户\ncreate user &#39;test&#39;@&#39;%&#39; identified by &#39;123123&#39;;   \n# 再进行授权\ngrant all privileges on *.* to &#39;test&#39;@&#39;%&#39; with grant option;\n\n# 修改远程加密规则:\nALTER USER &#39;test&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123123&#39;;\n\n# 刷新权限:\nFLUSH PRIVILEGES;\n#OK，设置完成，再次使用 Navicat 连接数据库\n\n","categories":["docker"],"tags":["数据库","mysql"]},{"title":"mysql安装 ( linux压缩包 )","url":"/2022/11/22/mysql/mysql%E5%AE%89%E8%A3%85%20(%20linux%E5%8E%8B%E7%BC%A9%E5%8C%85%20)/","content":"\n压缩包安装方便修改配置下载，到MySQL官网 ,点击Downloads=&gt;Community=&gt;MySQL Community Server\n\n环境配置监测本机是否存在mysqlrpm -qa|grep -i mysql\n查找之前的MySQL目录，并使用rm -rf 文件夹名，删除find / -name mysql。\n\n安装解压下载后的版本tar -zxvf mysql-5.7.37-linux-glibc2.12-x86_64.tar.gz\n\n将解压后的MySQL移动到自己想要的位置mv mysql-5.7.37-linux-glibc2.12-x86_64  /data/mysql\n\n安装数据库在MySQL目录下新建data目录cd /data/mysql \nmkdir data\n\n在系统中新建/etc/my.cnf，文件内容如下，目录可改成本机的：cd /etc/my.cnf\nvi my.cnf\n\n[mysqld]# 不需要密码验证skip-grant-tablesdatadir=/usr/local/mysql/databasedir=/usr/local/mysqlsocket=/tmp/mysql.sockuser=mysqlport=3306character-set-server=utf8# 是否区分大小写，0:区分大小写(默认), 1:不区分大小写lower_case_table_names=0# 允许最大连接数max_connections=20＃ 创建新表时将使用的默认引擎default-storage-engine=INNODB# 建议禁用符号链接以防止各种安全风险symbolic-links=0[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid\n\n打开vim /etc/profilevim /etc/profile\nexport PATH=$PATH:/usr/local/mysql/bin\nsource /etc/profile\n\n在MySQL目录下执行如下命令，初始化数据库./bin/mysqld --initialize --user=mysql --basedir=/data/mysql/ --datadir=/data/mysql/data/\n\n启动service mysql start\n\n","categories":["数据库"],"tags":["linux","mysql"]},{"title":"mysql安装 ( windows压缩包 )","url":"/2020/10/06/mysql/mysql%E5%AE%89%E8%A3%85%20(%20windows%E5%8E%8B%E7%BC%A9%E5%8C%85%20)/","content":"\n压缩包安装方便修改配置下载，到MySQL官网 ,点击Downloads=&gt;Community=&gt;MySQL Community Server \n\n解压安装包配置my.ini文件[mysql]#设置mysql客户端默认字符集default-character-set=utf8[mysqld]#设置3306端口port = 3306#设置mysql的安装目录basedir=E:\\mysql5.7# 默认时区default-time-zone=&#x27;+8:00&#x27;#设置mysql数据库的数据的存放目录datadir=E:\\mysql5.7\\data#允许最大连接数max_connections=200#服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8#创建新表时将使用的默认存储引擎explicit_defaults_for_timestamp=truedefault-storage-engine=INNODBwait_timeout=1814400#sqlmodelsql_mode =STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\n\n配置环境变量\nPath：E:\\mysql5.7\\bin\n\n\n安装mysql   以管理员身份打开cmd窗口,进入mysql目录执行命令:mysqld --initialize-insecure#进行初始化，会在bin同级目录下生成一个data目录#等待提示安装成功后，输入命令：mysqld -install [服务名]最后，输入命令：net start mysql ，启动服务。\n修改root密码执行mysql -u root -p回车，不用输密码，继续回车进入mysql修改密码命令 set password = password(‘123456’)\n\n","categories":["数据库"],"tags":["mysql"]},{"title":"数据库的设计以及优化","url":"/2020/10/06/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/","content":"表的设计具体注意的问题:\n数据行的长度不要超过8020字节，如果超过这个长度的话在物理页中这条数据会占用两行从而造成存储碎片降低查询效率。\n能够用数字类型的字段尽量选择数字类型而不用字符串类型的（电话号码），这会降低查询和连接的性能，会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要较一次就够了。\n对于不可变字符类型char和可变字符类型varchar都是8000字节,char查询快，但是耗存储空间，varchar查询相对慢一些但是节省存储空间。在设计字段的时候以灵活选择，例如用户名、密码等长度变化不大的字段可以选择CHAR，对于评论等长度变化大的字段可以选择VACHAR。\n字段的长度在最大限度的满足可能的需要的前提下，应该尽可能的设得短一些，这样可以提高查询的效率，而且在建立索引的时候也可以减少资源的消耗。\n\n查询优化\n保证在实现功能的基础上，尽量减少对数据库的访问次数(可以用缓存保存查询结果，减少查询次数)；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担;\n能够分开的操作尽量分开处理，提高每次的响应速度;\n在数据窗口使用SQL时，尽量把使用的索引放在选择的首列;\n算法的结构尽量简单;\n在查询时,不要过多地使用通配符如SELECT * FROM T1语句，要用到几列就选择几列如：SELECTCOL1,COL2 FROM T1；\n在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。\n应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n\nselect id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0\n\n\n应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行.\n应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：\n\nselect id from t where num=10 or num=20可以这样查询： select id from t where num=10union allselect id from t where num=20\n\n\nin 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。如：\n\nselect id from t where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3\n\n\n尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。见如下例子：\n\nSELECT * FROM T1 WHERE NAME LIKE ‘%L%’SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=’L’SELECT * FROM T1 WHERE NAME LIKE ‘L%’即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。\n\n\n必要时强制查询优化器使用某个索引，如在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：\n\nselect id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num\n\n\n应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n\nSELECT * FROM T1 WHERE F1/2=100应改为:SELECT * FROM T1 WHERE F1=100*2SELECT * FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=’5378’\n\n\n应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n\nselect id from t where substring(name,1,3)=&#x27;abc&#x27;--name以abc开头的idselect id from t where datediff(day,createdate,&#x27;2005-11-30&#x27;)=0--‘2005-11-30’生成的id应改为:select id from t where name like &#x27;abc%&#x27;select id from t where createdate&gt;=&#x27;2005-11-30&#x27; and createdate&lt;&#x27;2005-12-1&#x27;\n\n\n不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。\n很多时候用 exists是一个好的选择：\n\nselect num from a where num in(select num from b)可以替换为:select num from a where exists(select 1 from b where num=a.num)\n\n两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。18. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）19. 避免频繁创建和删除临时表，以减少系统表资源的消耗。20. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。21. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。22. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。23. 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。24. 尽量避免大事务操作，提高系统并发能力。25. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。26. 避免使用不兼容的数据类型。例如float和int、char和varchar、binary和varbinary是不兼容的（条件判断时）。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如:\nSELECT name FROM employee WHERE salary &gt; 60000在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。\n\n\n充分利用连接条件（条件越多越快），在某种情况下，两个表之间可能不只一个的连接条件，这时在 WHERE 子句中将连接条件完整的写上，有可能大大提高查询速度。例：\n\nSELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NOSELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO第二句将比第一句执行快得多。\n\n\n使用视图加速查询把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如：\n\nSELECT cust.name，rcvbles.balance，……other columnsFROM cust，rcvblesWHERE cust.customer_id = rcvlbes.customer_idAND rcvblls.balance&gt;0AND cust.postcode&gt;“98000”ORDER BY cust.name\n\n\n能用DISTINCT的就不用GROUP BY （group by 操作特别慢)\n\nSELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID可改为SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10\n\n\n能用UNION ALL就不要用UNION,UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源\n尽量不要用SELECT INTO语句。SELECT INOT 语句会导致表锁定，阻止其他用户访问该表。上面我们提到的是一些基本的提高查询速度的注意事项,但是在更多的情况下,往往需要反复试验比较不同的语句以得到最佳方案。最好的方法当然是测试，看实现相同功能的SQL语句哪个执行时间最少，但是数据库中如果数据量很少，是比较不出来的，这时可以用查看执行计划，即：把实现相同功能的多条SQL语句考到查询分析器，按CTRL+L看查所利用的索引，表扫描次数（这两个对性能影响最大），总体上看询成本百分比即可。\n\n算法的优化尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。\n与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。\n游标提供了对特定集合中逐行扫描的手段，一般使用游标逐行遍历数据，根据取出的数据不同条件进行不同的操作。尤其对多表和大表定义的游标（大的数据集合）循环很容易使程序进入一个漫长的等特甚至死机。\n在有些场合，有时也非得使用游标，此时也可考虑将符合条件的数据行转入临时表中，再对临时表定义游标进行操作，可时性能得到明显提高。（例如：对内统计第一版）封装存储过程\n建立高效的索引“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。\n所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。\n创建索引一般有以下两个目的：维护被索引列的唯一性和提供快速访问表中数据的策略。大型数据库有两种索引即簇索引和非簇索引，一个没有簇索引的表是按堆结构存储数据，所有的数据均添加在表的尾部，而建立了簇索引的表，其数据在物理上会按照簇索引键的顺序存储，一个表只允许有一个簇索引，因此，根据B树结构，可以理解添加任何一种索引均能提高按索引列查询的速度，但会降低插入、更新、删除操作的性能，尤其是当填充因子（Fill Factor）较大时。\n所以对索引较多的表进行频繁的插入、更新、删除操作，建表和索引时因设置较小的填充因子，以便在各数据页中留下较多的自由空间，减少页分割及重新组织的工作。\n索引是从数据库中获取数据的最高效方式之一。95% 的数据库性能问题都可以采用索引技术得到解决。作为一条规则，我通常对逻辑主键使用唯一的成组索引，对系统键（作为存储过程）采用唯一的非成组索引，对任何外键列[字段]采用非成组索引。不过，索引就象是盐，太多了菜就咸了。你得考虑数据库的空间有多大，表如何进行访问，还有这些访问是否主要用作读写。\n实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。\n如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。\n","categories":["数据库"],"tags":["mysql","数据库优化"]},{"title":"Centos操作","url":"/2024/03/26/operation/Centos%E6%93%8D%E4%BD%9C/","content":"基础操作网络配置防火墙# 查看已开启的端口firewall-cmd --list-ports#查看防火墙状态firewall-cmd --state#开启防火墙systemctl start firewalld#开启端口firewall-cmd --zone=public --add-port=6379/tcp --permanent#重启防火墙firewall-cmd --reload","categories":["服务器","Linux"],"tags":["CentOS"]},{"title":"Mysql命令","url":"/2020/10/06/operation/Mysql%E5%91%BD%E4%BB%A4/","content":"基础操作命令查看用户信息select user, host from mysql.user;\n\n创建用户添加权限 ( 所有数据库用 * 代替 )grant all privileges on 数据库名.* to 账号@localhost identified by &#39;密码&#39;;\ngrant all privileges on 数据库名.* to 账号@&#39;%&#39; identified by &#39;密码&#39;;\n\n刷新权限FLUSH PRIVILEGES;\n\n修改密码update user set authentication_string=password(&#39;新密码&#39;) where user=&#39;root&#39; and Host=&#39;localhost&#39;;\n\n删除用户DROP USER &#39;test&#39;@&#39;localhost&#39;;\n\n显示修改超时等待时间show global variables like &#39;wait_timeout&#39;;\nset global wait_timeout=600;\n\n显示修改最大连接数SHOW VARIABLES LIKE &#39;%max_con%&#39;;\nSET GLOBAL max_connections = 1000;\n\n忽略大小写lower_case_table_names=1\n\n解决group by问题sql_mode=&quot;IGNORE_SPACE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;\n\nmysql8之后操作#必须先创建用户(密码规则：mysql8.0以上密码策略限制必须要大小写加数字特殊符号)：\ncreate user matt@&#39;%&#39; identified  by &#39;Matt1234.&#39;;\n#再进行赋值\ngrant all privileges on *.* to matt@&#39;%&#39; with grant option;\nflush privileges;\n#mysql8使用的是caching_sha2_password加密规则，最简单的方法是修改远程连接用户的加密规则：\nALTER USER &#39;matt&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Matt1234.&#39;;\n\nSQL操作","categories":["数据库"],"tags":["mysql","命令行","操作"]},{"title":"docker常用命令操作","url":"/2022/11/22/operation/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","content":"基础命令启动dockersystemctl start docker\n\n关闭dockersystemctl stop docker\n\n重启dockersystemctl restart docker\n\ndocker设置随服务启动而自启动systemctl enable docker\n\n查看docker 运行状态systemctl status docker\n\n查看docker 版本号信息docker version\ndocker info\n\n镜像命令下载镜像docker pull 镜像名 \ndocker pull 镜像名:tag\n\n查看镜像docker images\n\n重新命名docker tag 旧镜像:版本 新镜像:版本\n\n搜索镜像docker search 镜像名\ndocker search --filter=STARS=9000 mysql 搜索 STARS &gt;9000的 mysql 镜像\n\n删除镜像#删除一个\ndocker rmi -f 镜像名/镜像ID\n\n#删除多个 其镜像ID或镜像用用空格隔开即可\ndocker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID\n\n#删除全部镜像  -a 意思为显示全部, -q 意思为只显示ID\ndocker rmi -f $(docker images -aq)\n\n强制删除镜像docker image rm 镜像名称/镜像ID\n\n导出/导入镜像export/importexport导出docker export f299f501774c &gt; hangger_server.tar\n\nimport导入docker import - new_hangger_server &lt; hangger_server.tar\n\nsave/loadsave导出docker save 0fdf2b4c26d3 &gt; hangge_server.tar\n# 还可以同时将多个 image 打包成一个文件，比如下面将镜像库中的 postgres 和 mongo 打包：\ndocker save -o images.tar postgres:9.6 mongo:3.4\n\nload导入docker load &lt; hangge_server.tar\n\n区别\n特别注意：两种方法不可混用。如果使用 import 导入 save 产生的文件，虽然导入不提示错误，但是启动容器时会提示失败，会出现类似”docker: Error response from daemon: Container command not found or does not exist”的错误。\n\n1. 文件大小不同export 导出的镜像文件体积小于 save 保存的镜像2. 是否可以对镜像重命名docker import 可以为镜像指定新名称docker load 不能对载入的镜像重命名3. 是否可以同时将多个镜像打包到一个文件中docker export 不支持docker save 支持4. 是否包含镜像历史export 导出（import 导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息（即仅保存容器当时的快照状态），所以无法进行回滚操作。而 save 保存（load 加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。5. 应用场景不同docker export 的应用场景：主要用来制作基础镜像，比如我们从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。docker save 的应用场景：如果我们的应用是使用 docker-compose.yml 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。\n\n容器命令启动容器docker run  镜像名\n# -it 表示 与容器进行交互式启动 -d 表示可后台运行容器 （守护式运行）  --name 给要运行的容器 起的名字  /bin/bash  交互路径\ndocker run -it -d --name 要取的别名 镜像名:Tag /bin/bash\n\n查看启动容器docker ps\n\n查看所有容器docker ps -a\n\n删除容器#删除一个容器\ndocker rm -f 容器名/容器ID\n\n#删除多个容器 空格隔开要删除的容器名或容器ID\ndocker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID\n\n#删除全部容器\ndocker rm -f $(docker ps -aq)\n\n进入容器docker exec -it 容器名/容器ID /bin/bash\n#进入redis001容器   \ndocker exec -it redis001 /bin/bash\n\ndocker attach 容器名/容器ID\n\n停止容器docker stop 容器ID/容器名\n\n重启容器docker restart 容器ID/容器名\n\n启动容器docker start 容器ID/容器名\n\nkill 容器docker kill 容器ID/容器名\n\n容器文件拷贝#docker cp 容器ID/名称:文件路径  要拷贝到外部的路径 | 要拷贝到外部的路径  容器ID/名称:文件路径\n#从容器内 拷出\ndocker cp 容器ID/名称: 容器内路径  容器外路径\n#从外部 拷贝文件到容器内\ndocker  cp 容器外路径 容器ID/名称: 容器内路径\n\n查看容器日志docker logs -f --tail=要查看末尾多少行 默认all 容器ID\n\n更新容器配置docker  update --restart=always 容器Id 或者 容器名\n或\ndocker container update --restart=always 容器Id 或者 容器名\n\n更换容器名docker rename 容器ID/容器名 新容器名\n\n运维命令查看docker网络docker network ls\n\n创建docker网络docker network create app\n\n查看docker磁盘占用总体情况du -hs /var/lib/docker/\n\n查看Docker的磁盘使用具体情况docker system df\n\n删除 无用的容器和 镜像#  删除异常停止的容器\ndocker rm `docker ps -a | grep Exited | awk &#39;&#123;print $1&#125;&#39;`\n\n#  删除名称或标签为none的镜像\ndocker rmi -f  `docker images | grep &#39;&lt;none&gt;&#39; | awk &#39;&#123;print $3&#125;&#39;`\n\n清除所有无容器使用的镜像# 注意，此命令只要是镜像无容器使用（容器正常运行）都会被删除，包括容器临时停止\ndocker system prune -a\n\ndocker-composedocker-compose脚本version: &#x27;3.5&#x27;services:  redis:    # 镜像名    image: redis:bullseye    # 容器名    container_name: redis-6379    # 重启策略    restart: always    # 端口映射    ports:      - 6379:6379    environment:      # 设置环境变量 时区上海 编码UTF-8      TZ: Asia/Shanghai      LANG: en_US.UTF-8    volumes:      # 配置文件      - /home/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf:rw      # 数据文件      - /home/redis/data:/data:rw    command: redis-server --requirepass 123456# 网络networks:  default:    external:      name: hkzs\n\n启动和后台启动docker-compose up\ndocker-compose up -d \n\n执行指定docker-compose文件docker-compose -f docker-compose-test.yml up -d\n\n停止和重启以及彻底干掉容器docker-compose stop \ndocker-compose restart\ndocker-compose down\n\n","categories":["docker"],"tags":["命令行","操作"]},{"title":"VUE3+TS+ElementPlus二次封装分页","url":"/2023/02/20/web/VUE3+TS+ElementPlus%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%E5%88%86%E9%A1%B5/","content":"编写组件&lt;template&gt;  &lt;div :class=&quot;&#123; hidden: hidden &#125;&quot; class=&quot;pagination-container&quot;&gt;    &lt;el-pagination        v-model:current-page.sync=&quot;paginationData.current&quot;        v-model:page-size=&quot;paginationData.size&quot;        :style=&quot;&#123; float: props.isRight ? &#x27;right&#x27; : &#x27;&#x27; &#125;&quot;        :total=&quot;total&quot;        :small=&quot;small&quot;        :background=&quot;background&quot;        :layout=&quot;layout&quot;        :page-sizes=&quot;pageSizes&quot;        v-bind=&quot;$attrs&quot;        @size-change=&quot;handleSizeChange&quot;        @current-change=&quot;handleCurrentChange&quot;    /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive&#125; from &#x27;vue&#x27;const props = defineProps(&#123;  // 总数  total: &#123;    required: true,    type: Number,  &#125;,  // 页码  current: &#123;    type: Number,    default: 1,  &#125;,  // 每页数量  size: &#123;    type: Number,    default: 10,  &#125;,  // 每页显示数量  pageSizes: &#123;    type: Array,    default() &#123;      return [10, 20, 50, 100, 200]    &#125;,  &#125;,  // 显示组件布局  layout: &#123;    type: String,    default: &#x27;total, sizes, prev, pager, next, jumper&#x27;,  &#125;,  small: &#123;    type: Boolean,    default: false,  &#125;,  // 是否为分页按钮添加背景色  background: &#123;    type: Boolean,    default: true,  &#125;,  autoScroll: &#123;    type: Boolean,    default: true,  &#125;,  // 显示与否  hidden: &#123;    type: Boolean,    default: false,  &#125;,  // 是否居右  isRight: &#123;    type: Boolean,    default: false,  &#125;,&#125;)const emit = defineEmits([&#x27;update:current&#x27;, &#x27;update:size&#x27;, &#x27;pagination&#x27;])const paginationData = reactive(&#123;  current: props.current,  size: props.size,&#125;)const handleSizeChange = (val: number) =&gt; &#123;  emit(&#x27;update:size&#x27;, val)  emit(&#x27;pagination&#x27;, paginationData)&#125;const handleCurrentChange = (val: number) =&gt; &#123;  emit(&#x27;update:current&#x27;, val)  emit(&#x27;pagination&#x27;, paginationData)&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.pagination-container &#123;  overflow-x: auto;  margin-top: 20px;&#125;.pagination-container.hidden &#123;  display: none;&#125;&lt;/style&gt;\n\n使用组件&lt;template&gt;  &lt;Pagination      @pagination=&quot;handleChangePage&quot;      :total=&quot;state.tableData.total&quot;      :current=&quot;state.tableData.queryForm.current&quot;      :size=&quot;state.tableData.queryForm.size&quot;  /&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive&#125; from &#x27;vue&#x27;;const state = reactive(&#123;  tableData: &#123;    total: 0,    data: [],    queryForm: &#123;      current: 1,      size: 10,    &#125;,  &#125;,&#125;);// 分页操作const handleChangePage = (item: &#123; current: number; size: number &#125;) =&gt; &#123;  state.tableData.queryForm.current = item.current;  state.tableData.queryForm.size = item.size;&#125;;&lt;/script&gt;","categories":["web"],"tags":["VUE","分页组件","ElementPlus"]},{"title":"nginx部署vue前端","url":"/2023/06/07/web/nginx%E9%83%A8%E7%BD%B2vue%E5%89%8D%E7%AB%AF/","content":"nginx部署vue前端,增加项目访问前缀\n通常我们nginx部署前端只需要默认的端口访问如: http://127.0.0.1:8080,但是有时候多个项目部署在一个地址上,我们需要通过前缀来区分,例如http://127.0.0.1:8080/test1, http://127.0.0.1/test2.此时就需要非常规配置. 此处我们演示的是docker环境下的nginx配置.docker的nginx配置可以参考nginx部署 ( docker )\n\n\n无项目前缀, http://127.0.0.1:8080vue项目的vu.config.js配置, 注意publicPathmodule.exports = &#123;    publicPath: &#x27;/&#x27;,    assetsDir: &#x27;static&#x27;,    outputDir: &#x27;dist&#x27;,    chainWebpack: config =&gt; &#123;        config.resolve.alias.set(&#x27;@&#x27;, resolve(&#x27;src&#x27;))    &#125;,    // 开启调试    configureWebpack: &#123;        // devtool: process.env.NODE_ENV === &#x27;production&#x27; ? false : &#x27;source-map&#x27;,        devtool: &#x27;source-map&#x27;    &#125;,    devServer: &#123;        open: true, // 自动打开浏览器        host: &#x27;0.0.0.0&#x27;, // 对应的主机名        port: 8080, // 端口号        proxy: &#123;            [process.env.VUE_APP_BASE_API]: &#123;                target: process.env.VUE_APP_URL,                changeOrigin: true,                pathRewrite: &#123;                    [&#x27;^&#x27; + process.env.VUE_APP_BASE_API]: &#x27;&#x27;                &#125;            &#125;        &#125;    &#125;&#125;\n\nnginx的配置   listen       8080;   server_name  127.0.0.1;index index.html index.htm;   location / &#123;       # 此处为挂载目录的指定项目文件夹       root  /usr/share/nginx/html/test;       try_files $uri $uri/ /index.html;       index  index.html index.htm;   &#125;# 代理后端接口location /api/&#123;\tproxy_set_header Host $http_host;\tproxy_set_header X-Real-IP $remote_addr;\tproxy_set_header REMOTE-HOST $remote_addr;\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t# 后端接口地址\tproxy_pass http://127.0.0.1:9999/;   &#125;\n\n\n有项目前缀, http://127.0.0.1:8080/testvue项目的vu.config.js配置, 注意publicPathmodule.exports = &#123;    publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/test/&#x27; : &#x27;/&#x27;,    assetsDir: &#x27;static&#x27;,    outputDir: &#x27;dist&#x27;,    chainWebpack: config =&gt; &#123;        config.resolve.alias.set(&#x27;@&#x27;, resolve(&#x27;src&#x27;)).set(&#x27;api&#x27;, resolve(&#x27;service/api&#x27;))    &#125;,    // 开启调试    configureWebpack: &#123;        // devtool: process.env.NODE_ENV === &#x27;production&#x27; ? false : &#x27;source-map&#x27;,        devtool: &#x27;source-map&#x27;    &#125;,    devServer: &#123;        open: true, // 自动打开浏览器        host: &#x27;0.0.0.0&#x27;, // 对应的主机名        port: 8080, // 端口号        proxy: &#123;            [process.env.VUE_APP_BASE_API]: &#123;                target: process.env.VUE_APP_URL,                changeOrigin: true,                pathRewrite: &#123;                    [&#x27;^&#x27; + process.env.VUE_APP_BASE_API]: &#x27;&#x27;                &#125;            &#125;        &#125;    &#125;&#125;\n\nrouter/index.js配置vue2const router = new VueRouter(&#123;    mode: &#x27;history&#x27;,    base: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/test/&#x27; : &#x27;/&#x27;,    routes,&#125;)\n\nvue3const base = process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/test/&#x27; : &#x27;/&#x27;const router = createRouter(&#123;    history: createWebHashHistory(base),    routes,&#125;)\nnginx配置server &#123;    listen       8080;    server_name  127.0.0.1;\tindex index.html index.htm;\t     location / &#123;        root  html;        try_files $uri $uri/ /index.html;        index  index.html index.htm;    &#125;    location /test &#123;        # 这里要用别名天写项目包路径        alias  /usr/share/nginx/html/test/;        # 此处是 前缀/index.html        try_files $uri $uri/ /test/index.html;        index  index.html index.htm;    &#125;\t\tlocation /api/&#123;\t\tproxy_set_header Host $http_host;\t\tproxy_set_header X-Real-IP $remote_addr;\t\tproxy_set_header REMOTE-HOST $remote_addr;\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t\tproxy_pass http://127.0.0.1:9999/;    &#125; &#125;","categories":["web"],"tags":["nginx","VUE","前端"]}]